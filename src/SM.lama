-- Stack machine.
import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn (i) {
   case i of
      READ -> sprintf("READ")
   |  WRITE -> sprintf("WRITE")
   |  BINOP(s) -> sprintf("BINOP %s", s)
   |  LD(x) -> sprintf("LD %s", x)
   |  ST(x) -> sprintf("ST %s", x)
   |  CONST(n) -> sprintf("CONST %d", n)
   esac
}
public fun showSM (prg) {
   map(fun (i) {showSMInsn(i) ++ "\n"}, prg).stringcat
}
-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c, insns) {
   case insns of
      [] -> c
   |  READ -> 
         let [x, w] = readWorld(c[2]) in
         eval([x:c[0], c[1], w], tl(insns))
   |  WRITE -> 
         let newWorld = writeWorld(hd(c[0]), c[2]) in
         eval([tl(c[0]), c[1], newWorld], tl(insns))
   |  CONST(n) -> 
         eval([n : c[0], c[1], c[2]], tl(insns))
   |  LD(x) -> 
         eval([c[1](x) : c[0], c[1], c[2]], tl(insns))
   |  ST(x) -> 
         eval([tl(c[0]), c[1] <- [x, hd(c[0])], c[2]], tl(insns))
   |  BINOP(op) -> 
         let a = hd(tl(c[0])) in
         let b = hd(c[0]) in
         let res =
            case op of
               "+" -> a + b
            |  "-" -> a - b
            |  "*" -> a * b
            |  "/" -> a / b
            |  "%" -> a % b
            |  "<" -> if (a < b) then 1 else 0 fi
            |  "<=" -> if (a <= b) then 1 else 0 fi
            |  ">" -> if (a > b) then 1 else 0 fi
            |  ">=" -> if (a >= b) then 1 else 0 fi
            |  "==" -> if (a == b) then 1 else 0 fi
            |  "!=" -> if (a != b) then 1 else 0 fi
            |  "&&" -> if (a && b) then 1 else 0 fi
            |  "!!" -> if (a !! b) then 1 else 0 fi
            esac
         in eval([res : tl(tl(c[0])), c[1], c[2]], tl(insns))
      esac
}
-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
   eval([{}, emptyState, createWorld(input)], insns)[2].getOutput
}
-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
   case expr of
      Var(x) -> [LD(x)]
   |  Const(n) -> [CONST(n)]
   |  Binop(op, e1, e2) -> compileExpr(e1) ++ compileExpr(e2) ++ [BINOP(op)]
   esac
}
-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
   case stmt of
      Assn(x, e) -> compileExpr(e) ++ [ST(x)]
   |  Seq(s1, s2) -> compileSM(s1) ++ compileSM(s2)
   |  Skip -> []
   |  Read(x) -> [READ, ST(x)]
   |  Write(e) -> compileExpr(e) ++ [WRITE]
   esac
}
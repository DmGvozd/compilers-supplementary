-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun inbrs (parser) {
  inbr (s("("), parser, s(")"))
}

fun binop(l, op, r) {
  Binop (op, l, r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbrs[exp]),
      exp = memo $ expr ({
        [Left, {[s("!!"), binop]}],
        [Left, {[s("&&"), binop]}],
        [Nona, {[s("=="), binop],
                [s("!="), binop],
                [s("<="), binop],
                [s(">="), binop],
                [s("<"),  binop],
                [s(">"),  binop]}],
        [Left, {[s("+"),  binop],
                [s("-"),  binop]}],
        [Left, {[s("*"),  binop],
                [s("/"),  binop],
                [s("%"),  binop]}]
      }, primary);

var stmts = memo $ eta syntax (
  k = lident s[":="] l=exp {Assn (k, l)} |
  kSkip {Skip} |
  kRead x = inbrs[lident] {Read (x)} |
  kWrite e = inbrs[exp] {Write (e)} |
  kIf cnd=exp kThen t=stmt 
    brs = ( kElif cnd2=exp kThen t2=stmt { Br(cnd2, t2) } )* 
    nbr = (-kElse nbr=stmt)? kFi
    {
      let cnt = foldl
      (
        fun(acc, Br(c, s)) { fun(x) { acc(If(c, s, x)) } },
        fun(x) { If(cnd, t, x) }, brs
      ) 
      in 
      case nbr of
          Some(n) -> cnt(n)
        | _       -> cnt(Skip)
      esac
    } |
  kWhile cnd = exp kDo inr = stmt kOd { While (cnd, inr) } |
  kDo inr = stmt kWhile cnd = exp kOd { DoWhile (inr, cnd) } |
  kFor i = stmt s[","] cnd = exp s[","] incr = stmt kDo inr = stmt kOd 
  {
    Seq (i, While (cnd, Seq (inr, incr)))
  }
  ),
  stmt = memo $ eta syntax (s1=stmts s[";"] s2=stmt {Seq (s1, s2)} |
  stmts);

-- Public top-level parser
public parse = stmt;
